# Dishi - Database Schema

## Overview

Drizzle ORM schema for a hyperlocal food discovery platform. Kitchens register their home-cooked food, customers discover nearby options via geospatial search, and semantic embeddings power future dish recommendations.

PostgreSQL extensions required: **PostGIS** (geospatial), **pg_vector** (embeddings).

## Schema Structure

```
apps/api/src/db/
├── schema/
│   ├── auth-schema.ts       # Better Auth tables (auto-generated, do not modify)
│   ├── kitchen-schema.ts    # Kitchen profiles, cuisine types, kitchen-cuisine junction
│   ├── menu-schema.ts       # Menu categories and menu items
│   ├── customer-schema.ts   # Customer favorites and saved locations
│   └── index.ts             # Re-exports all schemas
└── client.ts                # Database client factory
```

Relations are defined using Drizzle's `relations()` helper, co-located with their table definitions. Each schema file owns its tables and their forward relations. The dependency flow is: `auth → kitchen → menu` and `auth + kitchen → customer` (no circular imports).

## Tables

### Auth Tables (Better Auth Managed)

These are auto-generated by Better Auth and must not be modified directly.

- **user** - User accounts with platform-level role (`platformAdmin` | `customer`)
- **session** - Sessions with impersonation support and active organization tracking
- **account** - OAuth/credential providers
- **verification** - Email/phone verification tokens
- **apikey** - API key authentication with rate limiting
- **organization** - Kitchens (Better Auth's org model; name and slug live here)
- **member** - Kitchen staff memberships with role (`owner` | `staff`)
- **invitation** - Pending kitchen staff invitations

### Application Tables

#### cuisine_type

Platform-managed reference table of cuisine categories. Seeded by admins, selected by kitchen owners during onboarding.

| Column | Type | Nullable | Description |
|--------|------|----------|-------------|
| id | text | PK | |
| name | text | not null | Display name, unique (e.g. "Swahili", "Indian") |
| slug | text | not null | URL-safe identifier, unique |
| icon | text | yes | Emoji or icon reference |

**Design decision:** Separate reference table (not an enum or tags column) because cuisines need slugs for URL routing (`/explore?cuisine=swahili`), icons for UI, and admin-controlled additions without schema migrations.

---

#### kitchen_profile

Extended profile for a kitchen. Has a **1:1 relationship** with `organization` - the org table holds name/slug/logo (managed by Better Auth), this table holds everything food-platform-specific.

| Column | Type | Nullable | Description |
|--------|------|----------|-------------|
| id | text | PK | |
| organization_id | text | not null | FK to `organization`, unique (enforces 1:1) |
| description | text | yes | About the kitchen |
| phone | text | yes | WhatsApp contact number |
| location | geometry(Point, 4326) | yes | PostGIS point (lng, lat) |
| address | text | yes | Human-readable street address |
| neighborhood | text | yes | Area/neighborhood name for filtering |
| delivery_radius_km | decimal(5,2) | yes | How far this kitchen delivers |
| is_open | boolean | not null | Current availability toggle, defaults `false` |
| opens_at | time | yes | Daily opening time |
| closes_at | time | yes | Daily closing time |
| operating_days | text[] | yes | Days of week (e.g. `['mon','tue','wed']`) |
| cover_image | text | yes | URL to cover photo |
| created_at | timestamp | not null | |
| updated_at | timestamp | not null | Auto-updates on change |

**Indexes:**
- `location` - GiST spatial, **partial** (`WHERE is_open = true`) — only indexes open kitchens for the "near me" hot path
- `neighborhood` - B-tree (filter by area)

Note: `organization_id` has a unique constraint which implicitly creates a unique index, so no separate B-tree index is needed.

**Design decisions:**
- **Separate from `organization`:** Better Auth owns the org table and auto-generates its schema. Coupling app fields into it would break on auth library updates. The 1:1 FK with `unique` constraint gives us clean separation.
- **`location` is nullable:** Kitchen profile is created step-by-step during onboarding; location may not be set immediately.
- **`operating_days` as text array:** More flexible than a bitmask or enum array. Easy to query with `@>` (contains) operator and trivial to serialize from frontend checkboxes.
- **`neighborhood` as plain text:** Neighborhoods are informal and city-specific. A reference table would over-normalize for the MVP. A B-tree index supports prefix matching and equality checks.

---

#### kitchen_cuisine (junction)

Many-to-many between kitchens and cuisine types. A kitchen can serve multiple cuisines.

| Column | Type | Nullable | Description |
|--------|------|----------|-------------|
| kitchen_id | text | not null | FK to `kitchen_profile`, composite PK |
| cuisine_id | text | not null | FK to `cuisine_type`, composite PK |

**Indexes:**
- `cuisine_id` - B-tree (reverse lookups: "which kitchens serve this cuisine?")

Note: `kitchen_id` does not need a standalone index because the composite PK `(kitchen_id, cuisine_id)` already covers kitchen_id-leading queries.

**Design decision:** Composite primary key (`kitchen_id, cuisine_id`) instead of a surrogate ID - this is a pure join table with no extra attributes. Both FKs cascade on delete.

---

#### menu_category

Organizes menu items into sections within a kitchen (e.g. "Main Dishes", "Drinks").

| Column | Type | Nullable | Description |
|--------|------|----------|-------------|
| id | text | PK | |
| kitchen_id | text | not null | FK to `kitchen_profile` |
| name | text | not null | Category name |
| sort_order | integer | not null | Display ordering, defaults `0` |
| created_at | timestamp | not null | |

**Design decision:** `sort_order` is an integer to allow drag-and-drop reordering on the dashboard. Categories are optional - menu items can exist without one.

---

#### menu_item

Individual dishes offered by a kitchen. The core searchable entity of the platform.

| Column | Type | Nullable | Description |
|--------|------|----------|-------------|
| id | text | PK | |
| kitchen_id | text | not null | FK to `kitchen_profile` |
| category_id | text | yes | FK to `menu_category` (set null on delete) |
| name | text | not null | Dish name |
| description | text | yes | What the dish is / ingredients |
| price | decimal(10,2) | not null | Price in local currency |
| image | text | yes | URL to dish photo |
| is_available | boolean | not null | Current availability, defaults `true` |
| is_daily_special | boolean | not null | Highlighted as today's special, defaults `false` |
| serving_size | text | yes | e.g. "1 plate", "500ml" |
| preparation_time_mins | integer | yes | Estimated prep time |
| dietary_tags | text[] | yes | e.g. `['vegetarian', 'halal', 'gluten-free']` |
| embedding | vector(1536) | yes | pg_vector embedding for semantic search |
| sort_order | integer | not null | Display ordering within category, defaults `0` |
| created_at | timestamp | not null | |
| updated_at | timestamp | not null | Auto-updates on change |

**Indexes:**
- `(kitchen_id, is_available)` - composite B-tree (covers "available items for kitchen X" in one scan)
- `category_id` - B-tree (list items per category)
- `(name, description)` - GIN full-text search (weighted: name=A, description=B)

**Design decisions:**
- **Full-text search index:** Uses `setweight` to rank name matches above description matches. The `coalesce` wrapper on description handles NULLs gracefully. Uses the `'simple'` dictionary (lowercase + whitespace split) instead of `'english'` so that Swahili and other non-English dish names tokenize correctly without language-specific stemming.
- **`embedding` is nullable:** pg_vector is for future semantic search and recommendations. Embeddings will be generated asynchronously (e.g. via background job after item creation). **No HNSW index yet** — add it via migration when embeddings are being populated (see TODO below).
- **`category_id` uses `SET NULL` on delete:** If a category is removed, its items remain uncategorized rather than being deleted. Preserves menu data.
- **`dietary_tags` as text array:** Flexible, no migration needed when new tags appear. Queryable with `@>` for filtering (e.g. "show only halal items").
- **`price` as decimal(10,2):** Avoids floating-point rounding issues. Supports prices up to 99,999,999.99 which covers any realistic local currency amount.

---

#### customer_favorite

Tracks which kitchens a customer has saved/bookmarked.

| Column | Type | Nullable | Description |
|--------|------|----------|-------------|
| id | text | PK | |
| user_id | text | not null | FK to `user` |
| kitchen_id | text | not null | FK to `kitchen_profile` |
| created_at | timestamp | not null | |

**Indexes:**
- `(user_id, kitchen_id)` - unique composite (prevents duplicates, also covers user_id-leading queries)
- `kitchen_id` - B-tree (reverse lookup: "who favorited this kitchen?")

Note: no standalone `user_id` index needed — the composite unique index covers user_id as its left prefix.

**Design decision:** Separate `id` primary key instead of using the composite unique as PK - simpler for API responses and potential future columns (e.g. notes, collections).

---

#### customer_location

Saved delivery addresses for a customer, each with a PostGIS point for distance calculations.

| Column | Type | Nullable | Description |
|--------|------|----------|-------------|
| id | text | PK | |
| user_id | text | not null | FK to `user` |
| label | text | not null | User-defined label (e.g. "Home", "Work") |
| location | geometry(Point, 4326) | not null | PostGIS point (lng, lat) |
| address | text | yes | Human-readable address |
| neighborhood | text | yes | Area name |
| is_default | boolean | not null | Primary address flag, defaults `false` |
| created_at | timestamp | not null | |

**Indexes:**
- `user_id` - B-tree (list addresses per user)
- `location` - GiST spatial (delivery radius checks)

**Design decision:** `location` is **required** here (unlike kitchen_profile) because a saved address without coordinates is useless for delivery radius checks. The GiST index enables fast `ST_DWithin` queries to determine if a customer is within a kitchen's delivery zone.

---

## Role System

### Platform Level (on `user.role`)

| Role | Description |
|------|-------------|
| `platformAdmin` | Full system control: manage users, verify/suspend kitchens, manage cuisines |
| `customer` | Default role: browse kitchens, view menus, manage favorites and saved locations |

### Kitchen Level (on `member.role`, organization-scoped)

| Role | Phase | Description |
|------|-------|-------------|
| `owner` | 1 | Full kitchen management (auto-assigned on creation) |
| `staff` | 1 | Edit menu, update availability |

Phase 2 will expand kitchen roles to: `owner`, `manager`, `frontDesk`, `cook`, `delivery`.

## PostgreSQL Extensions

Run once on your database before migrations:

```sql
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS vector;
```

## Migrations

From the api app:

```bash
pnpm --filter api db:gen
pnpm --filter api db:push
pnpm --filter api db:studio
```

## Usage Examples

### Find nearby open kitchens (PostGIS)

```typescript
import { sql } from "drizzle-orm";
import { kitchenProfile } from "@/db/schema";

const nearby = await db
  .select()
  .from(kitchenProfile)
  .where(
    sql`${kitchenProfile.isOpen} = true AND ST_DWithin(
      ${kitchenProfile.location},
      ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326),
      ${radiusMeters}
    )`,
  )
  .orderBy(
    sql`${kitchenProfile.location} <-> ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326)`,
  );
```

### Full-text search on menu items

```typescript
import { sql } from "drizzle-orm";
import { menuItem } from "@/db/schema";

const results = await db
  .select()
  .from(menuItem)
  .where(
    sql`(
      setweight(to_tsvector('simple', ${menuItem.name}), 'A') ||
      setweight(to_tsvector('simple', coalesce(${menuItem.description}, '')), 'B')
    ) @@ websearch_to_tsquery('simple', ${searchQuery})`,
  );
```

### Load kitchen with full menu (relational query)

```typescript
const kitchen = await db.query.kitchenProfile.findFirst({
  where: eq(kitchenProfile.organizationId, orgId),
  with: {
    organization: true,
    cuisines: { with: { cuisine: true } },
    menuCategories: {
      with: { items: true },
      orderBy: { sortOrder: "asc" },
    },
  },
});
```

### Load user favorites

```typescript
const favorites = await db.query.customerFavorite.findMany({
  where: eq(customerFavorite.userId, userId),
  with: {
    kitchen: {
      with: { organization: true },
    },
  },
});
```

## TODO

- [ ] **HNSW embedding index on `menu_item`**: When semantic search embeddings are being populated, add the HNSW index via migration:
  ```sql
  CREATE INDEX CONCURRENTLY menu_item_embedding_idx
    ON menu_item USING hnsw (embedding vector_cosine_ops);
  ```
  Or in Drizzle schema:
  ```typescript
  index("menu_item_embedding_idx").using("hnsw", table.embedding.op("vector_cosine_ops"))
  ```

## Entity Relationship Diagram

```
organization (Better Auth)
  │ 1:1
  ▼
kitchen_profile ──────────── kitchen_cuisine ──── cuisine_type
  │ 1:N                       (junction)
  ├── menu_category
  │     │ 1:N
  │     └── menu_item (full-text search + vector embedding)
  │
  └── customer_favorite
        │
user ───┤
        │
        └── customer_location (PostGIS required)
```

>[!NOTE]
> to drop all tabes run
```sql
DROP SCHEMA drizzle CASCADE;
DROP SCHEMA public CASCADE;
CREATE SCHEMA public;
```

>[!NOTE]
> When working locally remeber to install postgis and pg_vector
```sh
sudo apt update
sudo apt install postgresql-18-postgis-3 postgresql-18-postgis-3-scripts postgresql-18-pg-vector
```
